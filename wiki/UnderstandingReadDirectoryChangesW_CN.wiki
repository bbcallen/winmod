#labels ReadDirectoryChangesW
= 理解 ReadDirectoryChangesW =

 * 原作者：Jim Beveridge
 * 原文：[http://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html?amp]
 * 翻译：bbcallen@gmail.com

_世界上最长，最详细的 ReadDirectoryChangesW 的使用方法描述。_

[http://cid-e030bb50921fff08.skydrive.live.com/self.aspx/.Public/Blog%20Sample%20Code/ReadDirectoryChanges.zip 下载本文的示例代码]

　　之前，我花了一周时间研究文档少得可怜的 ReadDirectoryChangesW。希望这篇文章可以为大家节约一些时间。我相信我已经读过了我能找到所有相关文章和大量代码。几乎所有的例子，包括微软自己的那个例子，都有明显缺陷或低级错误。

　　我曾在《Multithreading Applications in Win32》这本书中的某一章，介绍了同步IO，激发态内核对象，重叠IO，IO完成端口的区别。现在要谈的这个问题，对我来说是小菜一碟。只不过上次写重叠IO的痛苦折磨了我好多年，这次应该也不会例外。


== 监控文件和目录的四种方式 ==

　　我们先看一下 SHChangeNotifyRegister，这个函数通过窗口消息实现，所以需要一个窗口句柄。它由Shell (Explorer)驱动，所以应用程序只会接收到 Shell 关心的通知，这些通知很难满足你的需求。它仅仅对监控用户对Explorer的操作有用。

　　在 Windows Vista 中，SHChangeNotifyRegister 已经可以报告所有文件的所有变更。但问题是，还存在上亿不打算立即升级的 Windows XP 用户。

　　由于 SHChangeNotifyRegister 基于窗口消息，所以还会带来性能上的问题。如果发生了太多文件变更，应用程序会不断接收到变更消息，你必须自己确认实际发生的事情。对于一部分应用程序来说，这实在是相当的囧。

　　Windows 2000 引入了两个新接口，[http://msdn.microsoft.com/en-us/library/aa364417%28VS.85%29.aspx FindFirstChangeNotification] 和 [http://msdn.microsoft.com/en-us/library/aa365465%28v=VS.85%29.aspx ReadDirectoryChangesW]。 FindFirstChangeNotification 很容易使用，但没有给出变更文件的信息。即便如此，这个函数对某些应用程序还是很有用的，比如传真服务和 SMTP 服务可以通过拖拽一个文件到一个目录来接受任务队列。ReadDirectoryChangesW 会给出变更的内容和方式, 不过相对的，在使用上也更复杂一些。

　　同 SHChangeNotifyRegister 一样，这两个新函数也会有性能问题。与 Shell 通知相比，它们的运行速度有明显提升，但在不同目录间移动上千个文件仍然会导致你丢失一部分(或者很多)通知。丢失通知的原因很[http://social.msdn.microsoft.com/forums/en-US/netfxbcl/thread/4465cafb-f4ed-434f-89d8-c85ced6ffaa8/ 复杂]。令人惊讶的是，似乎与你处理通知的速度有关。

　　*注意*，FindFirstChangeNotification 和 ReadDirectoryChangesW 是互斥的，不能同时使用。

　　Windows XP 引入了最终解决方案，[http://msdn.microsoft.com/en-us/library/aa363803%28VS.85%29.aspx 变更日志(Change Journal)]可以跟踪每一个变更的细节，即使你的软件没有运行。很帅的技术，但也相当难用。

　　第四个，同时也是最后一个解决方案需要安装[http://msdn.microsoft.com/en-us/library/ff548202.aspx 文件系统过滤驱动]，Sysinternals 的 FileMon 就使用了这种技术。在 Windows 驱动开发包(WDK)中有一个例子。这个方案本质上是一个[http://msdn.microsoft.com/en-us/library/ff548084.aspx 设备驱动]，如果没有正确的实现，有可能导致系统稳定性方面的问题。

　　对我来说，使用 ReadDirectoryChangesW，在性能和复杂度上会是一个很好的平衡。


== 谜题 ==

　　使用 ReadDirectoryChangesW 的最大挑战在于，在IO模式，处理信号，等待方式，以及线程模型这几个问题的整合上，存在数百种可能性。如果你不是 Win32 I/O 方面的专家，即使最简单的场景，你也很难搞定。

 * A. I/O模式:
  # 阻塞同步(Blocking synchronous)
  # 触发式同步(Signaled synchronous)
  # 重叠异步(Overlapped asynchronous)
  # 完成例程(Completion Routine) (又名 Asynchronous Procedure Call or APC)

 * B. 当调用 WaitForXxx 函数的时候:
  # 等待目录句柄
  # 等待 OVERLAPPED 结构体里的 Event 对象
  # 什么都不等 (APCs)

 * C. 处理通知:
  # 阻塞
  # WaitForSingleObject
  # WaitForMultipleObjects
  # WaitForMultipleObjectsEx
  # MsgWaitForMultipleObjectsEx
  # IO完成端口(I/O Completion Ports)

 * D. 线程模型:
  # 每个工作线程调用一次 ReadDirectoryChangesW.
  # 每个工作线程调用多次 ReadDirectoryChangesW.
  # 在主线程上调用多次 ReadDirectoryChangesW.
  # 多个线程进行多个调用. (I/O Completion Ports)

　　最后，当调用 ReadDirectoryChangesW 的时候，你可以通过 flags 选择你要监控的内容，包括文件创建，内容变更，属性变更等等。你可以多次调用，每次一个 flag，也可以在一次调用中使用多个 flag。多个 flag 总是正确的解决方案。但如果你为了调试方便，需要一个 flag 一个 flag 的调用的话，那就需要从 ReadDirectoryChangesW 返回的通知缓冲区中读取更多的数据。

　　如果你的脑子正在囧的话，那么你就能够明白为什么那么多人都没法搞定这件事了。


== 建议的解决方案 ==

　　那么正确的答案是什么呢？我的建议是：取决于你认为最重要的是什么。

　　*简单* - A2C3D1 - 在单独的线程中调用 ReadDirectoryChangesW，然后通过 PostMessage 发送给主线程。对于性能要求不高的 GUI 程序最合适。在 CodeProject 上的 [http://www.codeproject.com/KB/files/directorychangewatcher.aspx CDirectoryChangeWatcher] 就是使用的这个策略。微软的 [http://www.experts-exchange.com/Programming/Languages/CPP/Q_22507220.html FWATCH 例子] 也是使用的这个策略。

　　*性能* - A4C6D4 - 性能最好的解决方案是使用I/O完成端口，但是，这个激进的多线程方案是在太过负载，应当仅限在服务器上使用。对任何 GUI 程序来说，这个方案似乎都是不必要的。如果你不是一个多线程专家，请远离这个策略。

　　*平衡* - A4C5D3 - 通过完成例程(Completion Routines)，在一个线程中完成所有工作。你可以发起尽可能多的 ReadDirectoryChangesW 调用，由于完成例程是自动分派的，所有不需要等待任何句柄。你可以通过回调传递对象的指针，以便跟踪原始的数据结构。

　　起初我曾经认为 GUI 程序可以通过 MsgWaitForMultipleObjectsEx 将变更通知混入到窗口消息中。但由于对话框有自己的消息循环，当对话框显示的时候，通知便无法处理了。于是这个好主意被现实无情的碾碎了。


== 错误的技术 ==

　　在研究解决方案的时候，我见识过各种用法：不靠谱的，错误的，以及错得离谱的。

　　如果你正在使用上面提到的简单方案，不要使用阻塞调用，因为唯一取消调用的方法是关闭句柄(未在文档中列出的方法)，如果调用 Vista 之后的函数 [http://msdn.microsoft.com/en-us/library/aa363794%28VS.85%29.aspx CancelSynchronousIo]。正确的办法是使用触发式的同步I/O模式，也就是等待目录句柄。结束线程的时候，不要使用 TerminateThread，因为这个时候，资源无法释放，从而导致各种各样的问题。而是创建一个手动重置的 Event 对象，作为 WaitForMultipleObjects 等待的第二个句柄。当 Event 被设置的时候，退出线程。

　　如果你有上千个目录需要监控，不要使用简单方案。转换为平衡方案。或者监控公共的根目录，并忽略不关心的文件。

　　如果你需要监控整个驱动器，请三思。你会接收到每个临时文件，每个Internet缓存文件，每个应用程序数据变更的通知。简单来说，大量的通知会拖慢整个系统。如果你需要监控整个驱动器，你应当使用变更日志(Change Journal)。这样即使你的程序没有运行，也可以跟踪每一个变更。绝对不要用 FILE_NOTIFY_CHANGE_LAST_ACCESS 标志监控整个驱动器。

　　如果你使用了不带I/O完成端口的重叠I/O，不要等待句柄，而是使用完成例程(Completion Routines)。这样可以不受64个句柄的限制，可以让操作系统处理调用的分发，还可以通过 OVERLAPPED 传递你自己的对象指针。等一下我会给出例子。

　　如果你使用了工作线程，将结果传回给主线程的时候，不要使用 SendMessage，而是使用 PostMessage。如果主线程很繁忙，同步的 SendMessage 需要很久才能返回。这就失去了使用工作线程的意义了。

　　通过提供较大的缓冲区来尝试解决丢失通知的问题，会是一个诱人的选项。但这不是明智的行为。不管给定的缓冲区体积是多少，内核的未分页内存池都是分配相同大小的缓冲区。如果你分配太大的缓冲区，有可能导致包括蓝屏在内的一系列问题。感谢 MSDN 社区内容的匿名投稿人。